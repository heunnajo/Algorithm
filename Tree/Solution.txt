* 트리 순회
1. Preorder : 부모 노드로 자식 노드 값을 구할 때
2. Inorder
3. Postorder : 자식 노드 값으로 현재 노드 값을 구할 때
=> 각각 순회 순서보다 각각의 의미가 더 중요하다!

* 트리 종류
1. 이진 트리(Binary Tree) : 자식을 최대 2개만 가지고 있는 트리
2. 포화 이진 트리(Perfect Binary Tree)
- 리프노드를 제외한 노드의 자식의 수 2
- 리프 노드의 자식의 수 : 0
- 모든 리프 노듣의 깊이가 같아야 함
- 높이가 h인 트리의 노드 갯수 = 2^h -1
3. 완전 이진 트리(Complete Binary Tree)
- 리프 노드를 제외한 노드의 자식의 수 : 2
- 리프 노드의 자식의 수 : 0
- 마지막 레벨에는 노드가 일부는 없을 수도 있음
- 오른쪽에서부터 몇 개가 사라진 형태

* 트리의 표현
- 트리는 그래프이기 때문에 그래프의 표현과 같은 방식으로 저장할 수 있다.
- 또는 트리의 모든 노드는 부모를 하나 또는 0개만 가지기 때문에 부모만 저장하는 방식으로 저장할 수 있다.
- 부모가 0개인 경우는 트리의 루트인데, 이 경우 부모를 -1이나 0으로 처리하는 방식을 사용한다.

* 트리의 부모만 저장하는 방식 : Union-Find에서 이용
          1
      /      \
     2        3
    /  \     /  \
   4    5   6    7

   i      1 2 3 4 5 6 7
parent[i] 0 1 1 2 2 3 3

* 배열로 표현하는 방식
완전 이진 트리의 경우 배열로 표현 가능.
부모의 노드가 x인 경우 자식의 노드는 2*x, 2*x+1로 나타내면 된다.

* 구조체나 클래스 이용 방식 : 이진 트리의 경우
class Node {
  int left;  int right;
  Node(int left,int right){
  this.left = left; this.right = right;
}

* 트리의 탐색
- DFS/BFS 알고리즘을 이용할 수 있다.
- 트리는 사이클이 없는 그래프이기 때문에 임의의 두 정점 사이의 경로는 1개이다.
  =>경로가 1개기 때문에 찾은 그 경로가 최단 경로가 된다.=>DFS 이용해서 최단 거리 구할 수 있다.
  
* 트리의 지름
- 트리에 존재하는 모든 경로 중에서 가장 긴 것의 길이를 트리의 지름이라고 한다.
- 트리의 지름은 탐색 2번으로 구할 수 있다.
1. 한 정점 s에서 모든 정점까지의 거리를 구한다. 이 때, 가장 먼 거리인 정점을 u라고 한다.
2. u에서 모든 정점까지의 거리를 구한다. 이 때, 가장 먼 거리인 정점 v를 구한다.
3. d(u,v)를 u와 v사이의 거리라고 했을 때, d(u,v)가 트리의 지름이다.
          s
      /      \
     x        y
    /        /
   u        v    
<증명>
트리의 지름을 d(u,v) 라고 하자.
한 정점 s에서 BFS 탐색을 시작해서 가장 거리가 멀었던 정점을 x라고 하고,
x에서 BFS 탐색을 시작해서 가장 거리가 멀었던 정점을 y라고 하자.
wlog d(s,u) >= d(s,v)이다. 이 때, d(s,x) >= d(s,y)는 반드시 만족해야 한다.
이제 d(x,y) = d(u,v) 임을 증명하면 된다.
